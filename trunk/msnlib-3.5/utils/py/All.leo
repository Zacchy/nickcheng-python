<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.291324200913">
	<global_window_position top="88" left="273" height="762" width="1095"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="nickcheng.20070404101419" a="E"><vh>Applications</vh>
<v t="nickcheng.20070404101419.1"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/msnbot.py</vh>
<v t="nickcheng.20070404101419.2"><vh>&lt;&lt; msnbot declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101419.3"><vh>do_work</vh></v>
<v t="nickcheng.20070404101419.4"><vh>quit</vh></v>
</v>
<v t="nickcheng.20070404101530"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/exporter.py</vh>
<v t="nickcheng.20070404101530.1"><vh>&lt;&lt; exporter declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.2"><vh>class Patch</vh>
<v t="nickcheng.20070404101530.3"><vh>&lt;&lt; class Patch declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.4"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.5"><vh>tostr</vh></v>
<v t="nickcheng.20070404101530.6"><vh>export</vh></v>
</v>
<v t="nickcheng.20070404101530.7"><vh>class BuildPatchList</vh>
<v t="nickcheng.20070404101530.8"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.9"><vh>startElement</vh></v>
<v t="nickcheng.20070404101530.10"><vh>characters</vh></v>
<v t="nickcheng.20070404101530.11"><vh>endElement</vh></v>
</v>
</v>
<v t="nickcheng.20070404101530.12"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/hmerge.py</vh>
<v t="nickcheng.20070404101530.13"><vh>&lt;&lt; hmerge declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.14"><vh>get_records</vh></v>
<v t="nickcheng.20070404101530.15"><vh>panic</vh></v>
</v>
<v t="nickcheng.20070404101530.16"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/msncd.py</vh>
<v t="nickcheng.20070404101530.17"><vh>&lt;&lt; msncd declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.18"><vh>null</vh></v>
<v t="nickcheng.20070404101530.19"><vh>cb_iln</vh></v>
<v t="nickcheng.20070404101530.20"><vh>cb_nln</vh></v>
<v t="nickcheng.20070404101530.21"><vh>cb_fln</vh></v>
<v t="nickcheng.20070404101530.22"><vh>cb_out</vh></v>
<v t="nickcheng.20070404101530.23"><vh>cb_msg</vh></v>
<v t="nickcheng.20070404101530.24"><vh>cb_joi</vh></v>
<v t="nickcheng.20070404101530.25"><vh>cb_err</vh></v>
<v t="nickcheng.20070404101530.26"><vh>cb_add</vh></v>
<v t="nickcheng.20070404101530.27"><vh>cb_rem</vh></v>
<v t="nickcheng.20070404101530.28"><vh>login</vh></v>
<v t="nickcheng.20070404101530.29"><vh>psend</vh></v>
<v t="nickcheng.20070404101530.30"><vh>pipe_read</vh></v>
</v>
<v t="nickcheng.20070404101530.31"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/msntk.py</vh>
<v t="nickcheng.20070404101530.32"><vh>&lt;&lt; msntk declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.33"><vh>encode</vh></v>
<v t="nickcheng.20070404101530.34"><vh>decode</vh></v>
<v t="nickcheng.20070404101530.35"><vh>nick2email</vh></v>
<v t="nickcheng.20070404101530.36"><vh>email2nick</vh></v>
<v t="nickcheng.20070404101530.37"><vh>now</vh></v>
<v t="nickcheng.20070404101530.38"><vh>quit</vh></v>
<v t="nickcheng.20070404101530.39"><vh>class userlist</vh>
<v t="nickcheng.20070404101530.40"><vh>&lt;&lt; class userlist declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.41"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.42"><vh>create_chat</vh></v>
</v>
<v t="nickcheng.20070404101530.43"><vh>class mainmenu</vh>
<v t="nickcheng.20070404101530.44"><vh>&lt;&lt; class mainmenu declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.45"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.46"><vh>show_info</vh></v>
<v t="nickcheng.20070404101530.47"><vh>clear_heads</vh></v>
<v t="nickcheng.20070404101530.48"><vh>chst_online</vh></v>
<v t="nickcheng.20070404101530.49"><vh>chst_away</vh></v>
<v t="nickcheng.20070404101530.50"><vh>chst_busy</vh></v>
<v t="nickcheng.20070404101530.51"><vh>chst_brb</vh></v>
<v t="nickcheng.20070404101530.52"><vh>chst_lunch</vh></v>
<v t="nickcheng.20070404101530.53"><vh>chst_phone</vh></v>
<v t="nickcheng.20070404101530.54"><vh>chst_invisible</vh></v>
</v>
<v t="nickcheng.20070404101530.55"><vh>class chatwindow</vh>
<v t="nickcheng.20070404101530.56"><vh>&lt;&lt; class chatwindow declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.57"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.58"><vh>append</vh></v>
<v t="nickcheng.20070404101530.59"><vh>send_line</vh></v>
<v t="nickcheng.20070404101530.60"><vh>destroy_window</vh></v>
</v>
<v t="nickcheng.20070404101530.61"><vh>class infowindow</vh>
<v t="nickcheng.20070404101530.62"><vh>&lt;&lt; class infowindow declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.63"><vh>__init__</vh></v>
</v>
<v t="nickcheng.20070404101530.64"><vh>redraw_main</vh></v>
<v t="nickcheng.20070404101530.65"><vh>cb_msg</vh></v>
</v>
</v>
<v t="nickcheng.20070404101530.66" a="E"><vh>Libs</vh>
<v t="nickcheng.20070404101530.67" a="E"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/msnlib.py</vh>
<v t="nickcheng.20070404101530.68"><vh>&lt;&lt; msnlib declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.69"><vh>debug</vh></v>
<v t="nickcheng.20070404101530.70"><vh>nickquote</vh></v>
<v t="nickcheng.20070404101530.71"><vh>class user</vh>
<v t="nickcheng.20070404101530.72"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.73"><vh>__repr__</vh></v>
</v>
<v t="nickcheng.20070404101530.74"><vh>class sbd</vh>
<v t="nickcheng.20070404101530.75"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.76"><vh>__repr__</vh></v>
<v t="nickcheng.20070404101530.77"><vh>fileno</vh></v>
<v t="nickcheng.20070404101530.78"><vh>get_tid</vh></v>
</v>
<v t="nickcheng.20070404101530.79" a="E"><vh>class msnd</vh>
<v t="nickcheng.20070404101530.80" a="TV"><vh>__init__</vh></v>
<v t="nickcheng.20070404101530.81"><vh>__repr__</vh></v>
<v t="nickcheng.20070404101530.82"><vh>fileno</vh></v>
<v t="nickcheng.20070404101530.83"><vh>encode</vh></v>
<v t="nickcheng.20070404101530.84"><vh>decode</vh></v>
<v t="nickcheng.20070404101530.85"><vh>pollable</vh></v>
<v t="nickcheng.20070404101530.86"><vh>get_tid</vh></v>
<v t="nickcheng.20070404101530.87"><vh>_send</vh></v>
<v t="nickcheng.20070404101530.88"><vh>_recv</vh></v>
<v t="nickcheng.20070404101530.89"><vh>_recvmsg</vh></v>
<v t="nickcheng.20070404101530.90"><vh>submit_sbd</vh></v>
<v t="nickcheng.20070404101530.91"><vh>change_status</vh></v>
<v t="nickcheng.20070404101530.92"><vh>privacy</vh></v>
<v t="nickcheng.20070404101530.93"><vh>change_nick</vh></v>
<v t="nickcheng.20070404101530.94"><vh>sync</vh></v>
<v t="nickcheng.20070404101530.95"><vh>useradd</vh></v>
<v t="nickcheng.20070404101530.96"><vh>userdel</vh></v>
<v t="nickcheng.20070404101530.97"><vh>userren</vh></v>
<v t="nickcheng.20070404101530.98"><vh>userblock</vh></v>
<v t="nickcheng.20070404101530.99"><vh>userunblock</vh></v>
<v t="nickcheng.20070404101530.100"><vh>groupadd</vh></v>
<v t="nickcheng.20070404101530.101"><vh>groupdel</vh></v>
<v t="nickcheng.20070404101530.102"><vh>groupren</vh></v>
<v t="nickcheng.20070404101530.103"><vh>disconnect</vh></v>
<v t="nickcheng.20070404101530.104"><vh>close</vh></v>
<v t="nickcheng.20070404101530.105"><vh>invite</vh></v>
<v t="nickcheng.20070404101530.106"><vh>login</vh></v>
<v t="nickcheng.20070404101530.107"><vh>passport_auth</vh></v>
<v t="nickcheng.20070404101530.108"><vh>read</vh></v>
<v t="nickcheng.20070404101530.109"><vh>sendmsg</vh></v>
</v>
</v>
<v t="nickcheng.20070404101530.110" a="E"><vh>@file E:/Work/Code/Python/msnlib-3.5/utils/py/msncb.py</vh>
<v t="nickcheng.20070404101530.111"><vh>&lt;&lt; msncb declarations &gt;&gt;</vh></v>
<v t="nickcheng.20070404101530.112" a="E"><vh>class cb</vh>
<v t="nickcheng.20070404101530.113"><vh>__init__</vh></v>
</v>
<v t="nickcheng.20070404101530.114"><vh>cb_err</vh></v>
<v t="nickcheng.20070404101530.115"><vh>cb_def</vh></v>
<v t="nickcheng.20070404101530.116"><vh>cb_unk</vh></v>
<v t="nickcheng.20070404101530.117"><vh>cb_chl</vh></v>
<v t="nickcheng.20070404101530.118"><vh>cb_ign</vh></v>
<v t="nickcheng.20070404101530.119"><vh>cb_out</vh></v>
<v t="nickcheng.20070404101530.120"><vh>cb_iln</vh></v>
<v t="nickcheng.20070404101530.121"><vh>cb_fln</vh></v>
<v t="nickcheng.20070404101530.122"><vh>cb_nln</vh></v>
<v t="nickcheng.20070404101530.123"><vh>cb_bpr</vh></v>
<v t="nickcheng.20070404101530.124"><vh>cb_syn</vh></v>
<v t="nickcheng.20070404101530.125"><vh>cb_lst</vh></v>
<v t="nickcheng.20070404101530.126"><vh>cb_lsg</vh></v>
<v t="nickcheng.20070404101530.127"><vh>cb_prp</vh></v>
<v t="nickcheng.20070404101530.128"><vh>cb_add</vh></v>
<v t="nickcheng.20070404101530.129"><vh>cb_rem</vh></v>
<v t="nickcheng.20070404101530.130"><vh>cb_adg</vh></v>
<v t="nickcheng.20070404101530.131"><vh>cb_rmg</vh></v>
<v t="nickcheng.20070404101530.132"><vh>cb_reg</vh></v>
<v t="nickcheng.20070404101530.133"><vh>cb_rea</vh></v>
<v t="nickcheng.20070404101530.134"><vh>cb_rng</vh></v>
<v t="nickcheng.20070404101530.135"><vh>cb_xfr</vh></v>
<v t="nickcheng.20070404101530.136"><vh>cb_iro</vh></v>
<v t="nickcheng.20070404101530.137"><vh>cb_usr</vh></v>
<v t="nickcheng.20070404101530.138"><vh>cb_joi</vh></v>
<v t="nickcheng.20070404101530.139"><vh>cb_ans</vh></v>
<v t="nickcheng.20070404101530.140"><vh>cb_msg</vh></v>
<v t="nickcheng.20070404101530.141"><vh>cb_ack</vh></v>
<v t="nickcheng.20070404101530.142"><vh>cb_nak</vh></v>
<v t="nickcheng.20070404101530.143"><vh>cb_bye</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="nickcheng.20070404101419"></t>
<t tx="nickcheng.20070404101419.1">@ignore
@language python
&lt;&lt; msnbot declarations &gt;&gt;
@others

# we start a thread to do the work. it's a thread because we want to share
# everything, and fork cow semantics cause problems here
thread.start_new_thread(do_work, ())


# we loop over the network socket to get events
print "Loop"
while 1:
	# we get pollable fds
	t = m.pollable()
	infd = t[0]
	outfd = t[1]

	# we select, waiting for events
	try:
		fds = select.select(infd, outfd, [], 0)
	except:
		quit()
	
	for i in fds[0] + fds[1]:       # see msnlib.msnd.pollable.__doc__
		try:
			m.read(i)
		except ('SocketError', socket.error), err:
			if i != m:
				# user closed a connection
				# note that messages can be lost here
				m.close(i)
			else:
				# main socket closed
				quit()

	# sleep a bit so we don't take over the cpu
	time.sleep(0.01)



</t>
<t tx="nickcheng.20070404101419.2">#!/usr/bin/env python

"""
This is a very simple bot to show how automation using msnlib could be done.
It's not quite useful as-is, but provides a good example.

If you play with it, please let me know.
"""


# sys, for getting the parameters
import sys

# time, for sleeping
import time

# select to wait for events
import select

# socket, to catch errors
import socket

# thread, for creating the worker thread
import thread

# and, of course, msnlib
import msnlib
import msncb


m = msnlib.msnd()
m.cb = msncb.cb()


</t>
<t tx="nickcheng.20070404101419.3">def do_work():
	"""
	Here you do your stuff and send messages using m.sendmsg()
	This is the only place your code lives
	"""
	
	# wait a bit for everything to settle down (sync taking efect
	# basically)
	time.sleep(15)
	
	print '-' * 20 + 'SEND 1'
	print m.sendmsg("xx@me.com", "Message One")

	print '-' * 20 + 'SEND 2'
	print m.sendmsg("xx@me.com", "Message Two")

	# give time to send the messages
	time.sleep(30)

	# and then quit
	quit()
</t>
<t tx="nickcheng.20070404101419.4"># you shouldn't need to touch anything past here


# get the login email and password from the parameters
try:
	m.email = sys.argv[1]
	m.pwd = sys.argv[2]
except:
	print "Use: msnbot email password"
	sys.exit(1)


print "Logging In"
m.login()

print "Sync"
# this makes the server send you the contact list, and it's recommended that
# you do it because you can get in trouble when getting certain events from
# people that are not on your list; and it's not that expensive anyway
m.sync()

print "Changing Status"
# any non-offline status will do, otherwise we'll get an error from msn when
# sending a message
m.change_status("away")

def quit():
	try:
		m.disconnect()
	except:
		pass
	print "Exit"
	sys.exit(0)
</t>
<t tx="nickcheng.20070404101530">@ignore
@language python
&lt;&lt; exporter declarations &gt;&gt;
@others


# main

if len(sys.argv) &lt; 3:
	print "Use: exporter [xmlfile|-] [list|export destdir]"
	print
	print "Examples:"
	print " # darcs changes --xml-output | exporter - export /tmp"
	print " # darcs changes --xml-output | exporter - list"
	sys.exit(1)

if sys.argv[1] == '-':
	file = sys.stdin
else:
	file = sys.argv[1]

parser = make_parser()
parser.setFeature(feature_namespaces, 0)

handler = BuildPatchList()
parser.setContentHandler(handler)
parser.parse(file)

# reverse the list so the oldest is the first, and the newest is the last
handler.list.reverse()

# we now have two main structures: handler.db is the hash table of Patches,
# indexed by their hash, and handler.list is the ordered list of hashes.

if sys.argv[2] == 'list':
	c = 1
	for h in handler.list:
		print "%.2d:" % c, handler.db[h].tostr()
		c += 1
elif sys.argv[2] == 'export':
	if len(sys.argv) &lt; 4:
		print "Destination directory missing"
		sys.exit(1)
	c = 1
	for h in handler.list:
		p = handler.db[h]
		print "%.2d: %s" % (c, p.name)
		p.export(c, sys.argv[3])
		c += 1
else:
	print "Unknown parameter"

</t>
<t tx="nickcheng.20070404101530.1">#!/usr/bin/python

import sys
import os
from xml.sax import saxutils
from xml.sax import make_parser
from xml.sax.handler import feature_namespaces


</t>
<t tx="nickcheng.20070404101530.2">class Patch:
	&lt;&lt; class Patch declarations &gt;&gt;
	@others
</t>
<t tx="nickcheng.20070404101530.3">"Represents a single patch/record"
</t>
<t tx="nickcheng.20070404101530.4">def __init__(self):
	self.hash = ''
	self.author = ''
	self.date = ''
	self.local_date = ''
	self.name = ''
	self.comment = ''
</t>
<t tx="nickcheng.20070404101530.5">def tostr(self):
	s = "%s\n\tAuthor: %s\n\tDate: %s\n\tHash: %s\n" % \
		(self.name, self.author, self.date, self.hash)
	return s
</t>
<t tx="nickcheng.20070404101530.6">def export(self, order, path):
	# '/'s are not allowed in filenames
	name = self.name.replace('/', '-')

	# avoid 'name..patch'
	if name[-1] == '.':
		name = name[:-1]

	file = "%s/%.2d - %s.patch" % (path, order, name)
	cmd = 'darcs diff -u --match "hash %s" &gt; "%s"' % \
			(self.hash, file)
	if os.system(cmd):
		print "Command failed: '%s'" % cmd
</t>
<t tx="nickcheng.20070404101530.7">

class BuildPatchList(saxutils.DefaultHandler):
	@others
</t>
<t tx="nickcheng.20070404101530.8">def __init__(self):
	self.db = {}
	self.list = []
	self.cur_hash = ''
	self.cur_elem = None
	self.cur_val = ''
</t>
<t tx="nickcheng.20070404101530.9">def startElement(self, name, attrs):
	if name == 'patch':
		p = Patch()
		p.author = attrs.get('author', None)
		p.date = attrs.get('date', None)
		p.local_date = attrs.get('local_date', None)
		p.hash = attrs.get('hash')
		self.db[p.hash] = p
		self.current = p.hash
		self.list.append(p.hash)
	elif name == 'name':
		self.db[self.current].name = ''
		self.cur_elem = 'name'
	elif name == 'comment':
		self.db[self.current].comment = ''
		self.cur_elem = 'name'
	else:
		self.cur_elem = None
</t>
<t tx="nickcheng.20070404101530.10">def characters(self, s):
	if not self.cur_elem:
		return
	self.cur_val += s
</t>
<t tx="nickcheng.20070404101530.11">def endElement(self, name):
	if name == 'name':
		self.db[self.current].name = self.cur_val
	elif name == 'comment':
		self.db[self.current].current = self.cur_val

	self.cur_elem = None
	self.cur_val = ''
</t>
<t tx="nickcheng.20070404101530.12">@ignore
@language python
&lt;&lt; hmerge declarations &gt;&gt;
@others

try:
	fd1 = open(sys.argv[1])
	fd2 = open(sys.argv[2])
except:
	panic("Use: hmerge file1 file2")

# this is the invalid record to mark the end of the record list
eor_record = (0, '')


rec1 = get_records(fd1)
rec2 = get_records(fd2)

if not rec1: panic("Error: file 1 doesn't have any records")
if not rec2: panic("Error: file 1 doesn't have any records")

# append the eor_record to both lists
rec1.append(eor_record)
rec2.append(eor_record)

len1 = len(rec1)
len2 = len(rec2)

point1 = 0
point2 = 0

while 1:
		
	r1 = rec1[point1]
	r2 = rec2[point2]
	
	# if we have any at the end, print it or exit
	if r1[0] == 0 or r2[0] == 0:
		# if we reach the end of both lists, we exit
		if r1[0] == 0 and r2[0] == 0:
			break
		if r1[0] == 0:
			print r2[1],
			point2 += 1
		elif r2[0] == 0:
			print r1[1],
			point1 += 1
	
	# otherwise, compare and print the earlier
	else:
		if r1[0] &lt; r2[0]:
			print r1[1],
			point1 += 1
		elif r1[0] &gt; r2[0]:
			print r2[1],
			point2 += 1
		else:
			print r1[1],
			print r2[1],
			point1 += 1
			point2 += 1
		

</t>
<t tx="nickcheng.20070404101530.13">#!/usr/bin/env python

"""
Merger for msnlib logfiles.

It takes two logfiles as arguments, and prints out the merge between them,
sorting using the time.

Quite useful when you have used msn in two different places and want to unify
the logs.


Note that this will not do absolute time sorting (as it's usual for time to go
backwards, as we all know =), but record-by-record time compares.

Alberto Bertogli (albertogli@telpin.com.ar), 02/Jun/2003
Please send any reports to msnlib-devel@auriga.wearlab.de.
"""


import sys
import time


</t>
<t tx="nickcheng.20070404101530.14">def get_records(fd):
	records = []
	l = fd.readline()
	rec = l
	l = fd.readline()
	while rec:
		# if the line begins with \t, then it's a multi-line record
		if l and l[0] == '\t':
			rec += l
			l = fd.readline()
			continue
		
		# process the actual record
		ls = rec.split(' ', 2)
		raw_date = ls[0] + ' ' + ls[1]
		date = time.strptime(raw_date, '%d/%b/%Y %H:%M:%S ')
		date = time.mktime(date)
		records.append((date, rec))
		
		# save the current line
		rec = l
		l = fd.readline()
	return records
</t>
<t tx="nickcheng.20070404101530.15">def panic(s):
	print s
	sys.exit(1)
</t>
<t tx="nickcheng.20070404101530.16">@ignore
@language python
&lt;&lt; msncd declarations &gt;&gt;
@others
	
		

#
# now the real thing
#

# void the debug
msnlib.debug = null
msncb.debug = null

# POLL event queue
# We implement it in a very, very efficient way: text =)
# Yes, it's actually a list, but just because .append() is readable
# and allow us to keep track of the number of pending events
equeue = []

# open the socket for local communication
# we use datagram sockets to avoid complex reads and writes for now, but the
# protocol is line-oriented and perfectly capable of working over a stream
# socket.
pipe = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
pipe.bind(('127.0.0.1', 3030))


# loop, waiting for connections
while 1:
	infd = outfd = []
	# if we are connected, poll from msn
	if m.fd != None:
		t = m.pollable()
		infd = t[0]
		outfd = t[1]
	infd.append(pipe)

	fds = select.select(infd, outfd, [], 0)
	
	for i in fds[0] + fds[1]:	# see msnlib.msnd.pollable.__doc__
		if i == pipe:
			# read from the pipe
			pipe_read(pipe)
		else:
			try:
				m.read(i)
			except ('SocketError', socket.error), err:
				if i != m:
					# user closed a connection
					# note that messages can be
					# lost here
					equeue.append('SCLOSE USER %s %d\n' % (i.emails[0], len(i.msgqueue)) )
					m.close(i)
				else:
					# main socket closed
					# report
					equeue.append('SCLOSE MAIN\n')
					quit(1)


</t>
<t tx="nickcheng.20070404101530.17">#!/usr/bin/env python 


import sys
import os
import socket
import select
import string

import msnlib
import msncb


"""
MSN Client Daemon

This is a MSN client that reads commands from a named pipe, using
a little text-only protocol. It's main use is to serve as a 'glue'
to implement clients in other languages.

This is yet experimental because lack of testing, please let me know if you
try it out.
"""


</t>
<t tx="nickcheng.20070404101530.18">def null(s):
	"Null function, useful to void debug ones"
	pass
</t>
<t tx="nickcheng.20070404101530.19">#
# This are the callback replacements, which only handle the output and then
# call the original callbacks to do the lower level stuff
#

# basic classes
m = msnlib.msnd()
m.cb = msncb.cb()

# status change
def cb_iln(md, type, tid, params):
	t = params.split()
	status = msnlib.reverse_status[t[0]]
	email = t[1]
	equeue.append('STCH %s %s\n' % (email, status))
	msncb.cb_iln(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.20">m.cb.iln = cb_iln

def cb_nln(md, type, tid, params):
	status = msnlib.reverse_status[tid]
	t = string.split(params)
	email = t[0]
	equeue.append('STCH %s %s\n' % (email, status))
	msncb.cb_nln(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.21">m.cb.nln = cb_nln

def cb_fln(md, type, tid, params):
	email = tid
	u = m.users[email]
	discarded = 0
	if u.sbd and u.sbd.msgqueue:
		discarded = len(u.sbd.msgqueue)
	equeue.append('STCH %s offline %d\n' % (email, discarded))
	msncb.cb_fln(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.22">m.cb.fln = cb_fln

# server disconnect
def cb_out(md, type, tid, params):
	equeue.append('ERR SERV_DISC Server sent disconnect\n')
	msncb.cb_out(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.23">m.cb.out = cb_out


# message
def cb_msg(md, type, tid, params, sbd):
	t = string.split(tid)
	email = t[0]
	
	# messages from hotmail are only when we connect, and send things
	# regarding, aparently, hotmail issues. we ignore them (basically
	# because i couldn't care less; however if somebody has intrest in
	# these and provides some debug output i'll be happy to implement
	# parsing).
	if email == 'Hotmail':
		return

	# parse
	lines = string.split(params, '\n')
	headers = {}
	eoh = 1
	for i in lines:
		# end of headers
		if i == '\r':
			break
		tv = string.split(i, ':')
		type = tv[0]
		value = string.join(tv[1:], ':')
		value = string.strip(value)
		headers[type] = value
		eoh += 1
	
	if headers.has_key('Content-Type') and headers['Content-Type'] == 'text/x-msmsgscontrol':
		# the typing notices
		equeue.append('TYPING %s\n' % email)
	else:
		# messages
		equeue.append('MSG %d %d %s\n%s\n' % \
			(len(lines), eoh, email, string.join(lines, '\n')) )
	
	msncb.cb_msg(md, type, tid, params, sbd)
</t>
<t tx="nickcheng.20070404101530.24">m.cb.msg = cb_msg


# join a conversation and send pending messages
def cb_joi(md, type, tid, params, sbd):
	email = tid
	if len(sbd.msgqueue) &gt; 0:
		equeue.append('MFLUSH %s\n' % email)
	msncb.cb_joi(md, type, tid, params, sbd)
</t>
<t tx="nickcheng.20070404101530.25">m.cb.joi = cb_joi

# server errors
def cb_err(md, errno, params):
	if not msncb.error_table.has_key(errno):
		desc = 'Unknown'
	else:
		desc = msncb.error_table[errno]
	equeue.append('ERR %s %s\n' % (errno, desc))
	msncb.cb_err(md, errno, params)
</t>
<t tx="nickcheng.20070404101530.26">m.cb.err = cb_err
	
# users add, delete and modify
def cb_add(md, type, tid, params):
	t = params.split()
	type = t[0]
	if type == 'RL' or type == 'FL':
		email = t[2]
	if type == 'RL':
		equeue.append('UADD %s\n' % email)
	elif type == 'FL':
		equeue.append('ADDFL %s\n' % email)
	msncb.cb_add(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.27">m.cb.add = cb_add

def cb_rem(md, type, tid, params):
	t = params.split()
	type = t[0]
	if type == 'RL' or type == 'FL':
		email = t[2]
	if type == 'RL':
		equeue.append('UDEL %s\n' % email)
	elif type == 'FL':
		equeue.append('DELFL %s\n' % email)
	msncb.cb_rem(md, type, tid, params)
</t>
<t tx="nickcheng.20070404101530.28">m.cb.rem = cb_rem


def login(email, password):
	# login to msn
	printl('Logging in... ', c.green, 1)
	try:
		m.login()
		printl('done\n', c.green, 1)
	except 'AuthError', info:
		errno = int(info[0])
		if not msncb.error_table.has_key(errno):
			desc = 'Unknown'
		else:
			desc = msncb.error_table[errno]
		perror('Error: %s\n' % desc)
		quit(1)
	except KeyboardInterrupt:
		quit()
	except ('SocketError', socket.error), info:
		perror('Network error: ' + str(info) + '\n')
		quit(1)
	except:
		pexc('Exception logging in\n')
		quit(1)
</t>
<t tx="nickcheng.20070404101530.29">#
# the pipe read
#

# first, a small send wrapper to avoid repeating 'addr' all over the place
# note that as they are implemented using udp, if more than one client
# connects it can get quite quite messy
addr = ()
def psend(pipe, s):
	print '--&gt;', s,
	return pipe.sendto(s, addr)
</t>
<t tx="nickcheng.20070404101530.30"># read from the pipe, c being the pipe socket passed from the caller
def pipe_read(c):
	global m
	global addr
	global equeue	
	
	# we don't worry about lines too much in this implementation because
	# we use datagrams. however, when using stream sockets you should
	s, addr = c.recvfrom(4 * 1024)	# input buffer, should be enough
	print '&lt;--', s,
	try:
		s = s.split(' ', 1)
		if len(s) == 2:
			cmd, params = s
		else:
			cmd = s[0]
			params = ''

		cmd = cmd.strip()
		if params:
			params = params.strip()
			params = params.split(' ')
	except:
		psend(c, 'ERR EINVAL\n')
		return
	
	if cmd == 'LOGIN':
		if len(params) != 2:
			psend(c, 'ERR PARAMS\n')
			return
		try:
			email, pwd = params
			m.email = email
			m.pwd = pwd
			m.login()
			m.sync()
		except 'AuthError', info:
			errno = int(info[0])
			if not msncb.error_table.has_key(errno):
				desc = 'Unknown'
			else:
				desc = msncb.error_table[errno]
			psend(c, 'ERR MSN %d %s\n' % (errno, desc))
			return
		except ('SocketError', socket.error), info:
			psend(c, 'ERR SOCK %s\n' % str(info))
			return
		psend(c, 'OK\n')
		return
		
	elif cmd == 'LOGOFF':
		m.disconnect()
		psend(c, 'OK\n')
		return
		
	# if we are not connected, the following commands are not available
	if not m.fd:
		psend(c, 'ERR ENOTCONN\n')
		return
	
	
	if cmd == 'STATUS':
		status = string.join(params, ' ')
		if not m.change_status(status):
			psend(c, 'ERR UNK STATUS\n')
		else:
			psend(c, 'OK\n')
		return
		
	if cmd == 'POLL':
		equeue.append('POLLEND\n')
		for evt in equeue:
			psend(c, evt)
		equeue = []
		return
	
	if cmd == 'GETCL':
		psend(c, 'CL %d\n' % len(m.users.keys()) )
		for email in m.users.keys():
			u = m.users[email]
			status = msnlib.reverse_status[u.status]
			psend(c, '%s %s %s\n' % (status, email, u.nick))
		return
	
	if cmd == 'GETRCL':
		psend(c, 'CL %d\n' % len(m.reverse.keys()) )
		for email in m.reverse.keys():
			u = m.reverse[email]
			status = msnlib.reverse_status[u.status]
			psend(c, '%s %s %s\n' % (status, email, u.nick))
		return
	
	if cmd == 'INFO':
		if len(params) != 1:
			psend(c, 'ERR PARAMS\n')
			return
		if not m.users.has_key(email):
			psend(c, 'ERR UNK USER\n')
		u = m.users[email]
		psend(c, 'email = %s\n' % email)
		psend(c, 'nick = %s\n' % u.nick)
		psend(c, 'homep = %s\n' % u.homep)
		psend(c, 'workp = %s\n' % u.workp)
		psend(c, 'mobilep = %s\n' % u.mobilep)
		psend(c, '\n')
		return
	
	if cmd == 'ADD':
		if len(params) != 2:
			psend(c, 'ERR PARAMS\n')
			return
		nick, email = params
		m.useradd(email, nick)
		psend(c, 'OK\n')
		return
	
	if cmd == 'DEL':
		if len(params) != 1:
			psend(c, 'ERR PARAMS\n')
			return
		m.userdel(params)
		psend(c, 'OK\n')
		return
	
	if cmd == 'NICK':
		if len(params) != 1:
			psend(c, 'ERR PARAMS\n')
			return
		m.change_nick(params)
		psend(c, 'OK\n')
		return
	
	if cmd == 'PRIV':
		if len(params) != 2:
			psend(c, 'ERR PARAMS\n')
			return
		try:
			public = int(p[0])
			auth = int(p[1])
			if public not in (0, 1) or auth not in (0, 1):
				raise
		except:
			psend(c, 'ERR EINVAL\n')
			return
		m.privacy(public, auth)
		psend(c, 'OK\n')
		return
	
	if cmd == 'SENDMSG':
		params = string.join(params, ' ')
		params = string.split(params, '\n', 2)
		params, msg = params
		params = string.split(params, ' ')
		if len(params) &lt; 2:
			psend(c, 'ERR PARAMS\n')
			return
		lines = params[0]
		email = params[1]
		msg = msg
		m.sendmsg(email, msg)
		psend(c, 'OK\n')
		return
		
	# if we got here is because the command is unknown		
	psend(c, 'ERR UNK\n')
	return
</t>
<t tx="nickcheng.20070404101530.31">@ignore
@language python
&lt;&lt; msntk declarations &gt;&gt;
@others
m.cb.msg = cb_msg



#
# main
#

# email - chatwindow dictionary
emwin = {}

# gui init
root = Tk()
root.wm_title('msnlib')

mainlist = userlist(root)
mainlist.pack(side = TOP, fill = BOTH, expand = 1)

status = Label(root, text = "logging in...", bd=1, relief = SUNKEN, anchor = W)
status.pack(side = BOTTOM, fill = X, expand = 0)

menu = mainmenu(root)
root.config(menu = menu)

# initial update, to display at least something while we log in
root.update()

# ask for username and password if not given in the command line
if len(sys.argv) &lt; 3:
	m.email = tkSimpleDialog.askstring("Username",
		"Please insert your email")
	if not m.email:
		quit()
	
	m.pwd = tkSimpleDialog.askstring("Password",
		"Please insert your password")
	if not m.pwd:
		quit()
else:
	m.email = sys.argv[1]
	m.pwd = sys.argv[2]

m.email = m.email.strip()
m.pwd = m.pwd.strip()

# the encoding is utf-8 because the text class uses unicode directly
m.encoding = 'utf-8'

root.update()

# login
try:
	m.login()
	m.sync()
except 'AuthError':
	tkMessageBox.showerror("Login", "Error logging in: wrong password")
	quit()

# start as invisible
m.change_status('invisible')


# main loop
while 1:
	fds = m.pollable()
	infd = fds[0]
	outfd = fds[1]
	
	try:
		# both network and gui checks
		fds = select.select(infd, outfd, [], 0)
		root.update()
	except KeyboardInterrupt:
		quit()
	except TclError:
		quit()

	for i in fds[0] + fds[1]:
		try:
			m.read(i)
		except ('SocketError', socket.error), err:
			if i != m:
				m.close(i)
			else:
				tkMessageBox.showwarning("Warning",
					"Server disconnected us - you " +
					"probably logged in somewhere else")
				quit()
		
		# always redraw after a network event
		redraw_main()
	
	# sleep a bit so we don't take over the cpu
	time.sleep(0.05)


</t>
<t tx="nickcheng.20070404101530.32">#!/usr/bin/env python

import sys
import time
import string
import socket
import select
from Tkinter import *
import tkMessageBox
import tkSimpleDialog

import msnlib
import msncb

"""
MSN Tk Client

This is a beta msn client based on msnlib. As you see, it's GUI based on the
Tk bindings, which provide an abstraction to create graphical interfaces; it
works both under linux, windows and probably others too.

For further information refer to the documentation or the source (which is
always preferred).
Please direct any comments to the msnlib mailing list,
msnlib-devel@auriga.wearlab.de.
You can find more information, and the package itself, at
http://users.auriga.wearlab.de/~alb/msnlib
"""


# main msnlib classes
m = msnlib.msnd()
m.cb = msncb.cb()

# void debug output
#def void(s): pass
#msnlib.debug = msncb.debug = void



#
# useful functions
#

#sys.setdefaultencoding("iso-8859-15")
encoding = 'iso-8859-1'

</t>
<t tx="nickcheng.20070404101530.33">def encode(s):
	try:
		return s.decode(encoding).encode('utf-8')
	except:
		return s
</t>
<t tx="nickcheng.20070404101530.34">def decode(s):
	try:
		return s.decode('utf-8').encode(encoding)
	except:
		return s
</t>
<t tx="nickcheng.20070404101530.35">def nick2email(nick):
	"Returns an email according to the given nick, or None if noone matches"
	for email in m.users.keys():
		if str(m.users[email].nick) == str(nick):
			return email
	if nick in m.users.keys():
		return nick
	return None
</t>
<t tx="nickcheng.20070404101530.36">def email2nick(email):
	"Returns a nick accoriding to the given email, or None if noone matches"
	if email in m.users.keys():
		return m.users[email].nick
	else:
		return None
</t>
<t tx="nickcheng.20070404101530.37">def now():
	"Returns the current time in format HH:MM:SSTT"
	return time.strftime('%I:%M:%S%p', time.localtime(time.time()) )
</t>
<t tx="nickcheng.20070404101530.38">def quit():
	"Cleans up and quits everything"
	try:
		m.disconnect()
	except:
		pass
	root.quit()
	sys.exit(0)
</t>
<t tx="nickcheng.20070404101530.39">


#
# GUI classes
#

class userlist(Frame):
	&lt;&lt; class userlist declarations &gt;&gt;
	@others
</t>
<t tx="nickcheng.20070404101530.40">"The user list"
</t>
<t tx="nickcheng.20070404101530.41">def __init__(self, master):
	Frame.__init__(self, master)
	self.scrollbar = Scrollbar(self, orient = VERTICAL)
	self.list = Listbox(self, 
			yscrollcommand = self.scrollbar.set)
	self.list.config(font = "Courier")
	self.scrollbar.config(command = self.list.yview)
	self.scrollbar.pack(side = RIGHT, fill = Y)
	self.list.pack(side = LEFT, fill = BOTH, expand = 1)
	
	self.list.bind("&lt;Double-Button-1&gt;", self.create_chat)
</t>
<t tx="nickcheng.20070404101530.42">def create_chat(self, evt = None):
	"Creates a chat window"
	if m.status == 'HDN':
		tkMessageBox.showwarning("Warning", 
			"You can't open chats when you're invisible")
		return
	nick = self.list.get(self.list.curselection())[4:]
	email = nick2email(nick)
	if email in emwin.keys():
		emwin[email].lift()
	elif m.users[email].status == 'FLN':
		tkMessageBox.showwarning("Warning",
			"The user is offline")
	else:
		emwin[email] = chatwindow(root, email)
</t>
<t tx="nickcheng.20070404101530.43">	

class mainmenu(Menu):
	&lt;&lt; class mainmenu declarations &gt;&gt;
	@others
</t>
<t tx="nickcheng.20070404101530.44">"Main menu used in the main window"
</t>
<t tx="nickcheng.20070404101530.45">def __init__(self, master):
	Menu.__init__(self, master)
	self.status_menu = Menu(self, tearoff = 0)
	self.add_cascade(label = "Status", menu = self.status_menu)
	self.status_menu.add_command(label = "Online",
		command = self.chst_online)
	self.status_menu.add_command(label = "Away",
		command = self.chst_away)
	self.status_menu.add_command(label = "Busy",
		command = self.chst_busy)
	self.status_menu.add_command(label = "Be Right Back",
		command = self.chst_brb)
	self.status_menu.add_command(label = "Lunch",
		command = self.chst_lunch)
	self.status_menu.add_command(label = "Phone", 
		command = self.chst_phone)
	self.status_menu.add_command(label = "Invisible", 
		command = self.chst_invisible)
		
	self.add_command(label = 'Info', command = self.show_info)
</t>
<t tx="nickcheng.20070404101530.46">def show_info(self, evt = None):
	csel = mainlist.list.curselection()
	if not csel:
		return
	nick = mainlist.list.get(csel)[4:]
	email = nick2email(nick)
	infowindow(root, email)
</t>
<t tx="nickcheng.20070404101530.47"># status change callbacks
def clear_heads(self):
	for i in emwin.keys():
		emwin[i].head.config(text = '')
</t>
<t tx="nickcheng.20070404101530.48">def chst_online(self):
	self.clear_heads()
	m.change_status('online')
</t>
<t tx="nickcheng.20070404101530.49">def chst_away(self):
	self.clear_heads()
	m.change_status('away')
</t>
<t tx="nickcheng.20070404101530.50">def chst_busy(self):
	self.clear_heads()
	m.change_status('busy')
</t>
<t tx="nickcheng.20070404101530.51">def chst_brb(self):
	self.clear_heads()
	m.change_status('brb')
</t>
<t tx="nickcheng.20070404101530.52">def chst_lunch(self):
	self.clear_heads()
	m.change_status('lunch')
</t>
<t tx="nickcheng.20070404101530.53">def chst_phone(self):
	self.clear_heads()
	m.change_status('phone')
</t>
<t tx="nickcheng.20070404101530.54">def chst_invisible(self):
	warn = "Warning: as you are invisible, it is possible that\n"
	warn += "the messages you type here never get to the user."
	for i in emwin.keys():
		emwin[i].head.config(text = warn)
	m.change_status('invisible')
</t>
<t tx="nickcheng.20070404101530.55">

class chatwindow(Toplevel):
	&lt;&lt; class chatwindow declarations &gt;&gt;
	@others
</t>
<t tx="nickcheng.20070404101530.56">"Represents a chat window"
</t>
<t tx="nickcheng.20070404101530.57">def __init__(self, master, email):
	Toplevel.__init__(self, master)
	self.email = email
	self.protocol("WM_DELETE_WINDOW", self.destroy_window)
	nick = email2nick(email)
	# FIXME: update the title with status change
	status = msnlib.reverse_status[m.users[email].status]
	if nick:
		self.wm_title(nick + ' (' + status + ')')
	else:
		self.wm_title(email + ' (' + status + ')')

	# head label
	self.head = Label(self)
	self.head.pack(side = TOP, fill = X, expand = 0)
	self.head.config(justify = LEFT)
	self.head.config(text = "")

	# text box (with scrollbar), where the message goes
	self.frame = Frame(self)
	self.scrollbar = Scrollbar(self.frame, orient = VERTICAL)
	self.text = Text(self.frame, 
			yscrollcommand = self.scrollbar.set)
	self.scrollbar.config(command = self.text.yview)
	self.scrollbar.pack(side = RIGHT, fill = Y)
	self.text.pack(side = TOP, fill = BOTH, expand = 1)
	self.frame.pack(side = TOP, fill = BOTH, expand = 1)
	
	self.text.config(state = DISABLED)
	self.text.tag_config('from', foreground = 'blue')
	self.text.tag_config('to', foreground = 'red')
	self.text.tag_config('typing', foreground = 'lightblue')
	
	# entry, where the user types
	self.entry = Entry(self)
	self.entry.pack(side = BOTTOM, fill = X, expand = 0)
	self.entry.bind('&lt;Return&gt;', self.send_line)
</t>
<t tx="nickcheng.20070404101530.58">def append(self, s, direction, scroll = 1):
	"Adds text to the window's text box"
	self.text.config(state = NORMAL)
	self.text.insert(END, s, direction)
	self.text.yview(SCROLL, scroll, UNITS)
	self.text.config(state = DISABLED)
</t>
<t tx="nickcheng.20070404101530.59">def send_line(self, evt = None):
	"Sends the current entry as a message"
	msg = self.entry.get()
	lines = msg.split('\n')
	if len(lines) == 1:
		s = now() + ' &gt;&gt;&gt; ' + msg + '\n'
	else:
		s = now() + ' &gt;&gt;&gt;\n\t'
		s += string.join(lines, '\n\t')
		s = s[:-1]
	self.append(s, 'to', scroll = len(lines))
	
	# we need to encode it before sending because msg is already
	# an unicode string; so use utf-8
	msg = msg.encode('utf-8')

	m.sendmsg(self.email, msg)
	self.entry.delete(0, END)
</t>
<t tx="nickcheng.20070404101530.60">def destroy_window(self, evt = None):
	"Clean up when the window is closed"
	del(emwin[self.email])
	self.destroy()
</t>
<t tx="nickcheng.20070404101530.61">

class infowindow(Toplevel):
	&lt;&lt; class infowindow declarations &gt;&gt;
	@others
</t>
<t tx="nickcheng.20070404101530.62">"Represents a window with user information"
</t>
<t tx="nickcheng.20070404101530.63">def __init__(self, master, email):
	Toplevel.__init__(self, master)
	self.email = email
	self.wm_title('Info on ' + email)
	u = m.users[email]
	out = ''
	out += 'Information for user ' + email + '\n\n'
	out += 'Nick: ' + u.nick + '\n'
	out += 'Status: ' + msnlib.reverse_status[u.status] + '\n'
	if 'B' in u.lists:
		out += 'Mode: ' + 'blocked' + '\n'
	if u.gid != None:
		out += 'Group: ' + m.groups[u.gid] + '\n'
	if u.realnick:
		out += 'Real Nick: ' + u.realnick + '\n'
	if u.homep:
		out += 'Home phone: ' + u.homep + '\n'
	if u.workp:
		out += 'Work phone: ' + u.workp + '\n'
	if u.mobilep:
		out += 'Mobile phone: ' + u.mobilep + '\n'

	self.label = Label(self)
	self.label.pack(side = TOP, fill = BOTH, expand = 1)
	self.label.config(justify = LEFT)
	self.label.config(text = out)
</t>
<t tx="nickcheng.20070404101530.64">def redraw_main():
	"Redraws the main screen"
	# sync the user list - FIXME: instead of redrawing, use the callbacks
	# for status change notifications
	nicks = []
	for i in m.users.keys():
		if m.users[i].status == 'FLN':
			s = '[X] '
		elif m.users[i].status in ('NLN', 'IDL'):
			s = '[ ] '
		else:
			s = '[-] '
		if 'B' in m.users[i].lists:
			s = '[!] '
		
		s += m.users[i].nick
		nicks.append(s)
	nicks.sort()
	mainlist.list.delete(0, END)
	for i in nicks:
		mainlist.list.insert(END, i)
	
	# update status
	s = msnlib.reverse_status[m.status]
	status.config(text = s)
</t>
<t tx="nickcheng.20070404101530.65">#
# callbacks
#

def cb_msg(md, type, tid, params, sbd):
	"Gets a message"
	t = tid.split(' ')
	email = t[0]

	# parse
	lines = params.split('\n')
	headers = {} 
	eoh = 0
	for i in lines:
		# end of headers
		if i == '\r':
			break
		tv = i.split(':', 1)
		type = tv[0]
		value = tv[1].strip()
		headers[type] = value
		eoh += 1
	eoh +=1

	# ignore hotmail messages
	if email == 'Hotmail':
		return
	
	if email not in emwin.keys():
		emwin[email] = chatwindow(root, email)
		
	# typing notifications
	if (headers.has_key('Content-Type') and 
			headers['Content-Type'] == 'text/x-msmsgscontrol'):
		if not m.users[email].priv.has_key('typing'):
			m.users[email].priv['typing'] = 1
			msg = now() + ' --- is typing\n'
			emwin[email].append(msg, 'typing')
			
	# normal message
	else:
		if len(lines[eoh:]) &gt; 1:
			msg = now() + ' &lt;&lt;&lt;\n\t'
			msg += string.join(lines[eoh:], '\n\t')
			msg = msg.replace('\r', '')
		else:
			msg = now() + ' &lt;&lt;&lt; ' + lines[eoh] + '\n'
			
		if m.users[email].priv.has_key('typing'):
			del(m.users[email].priv['typing'])
			
		emwin[email].append(msg, 'from')
		root.bell()

	msncb.cb_msg(md, type, tid, params, sbd)
</t>
<t tx="nickcheng.20070404101530.66"></t>
<t tx="nickcheng.20070404101530.67">@ignore
@language python
&lt;&lt; msnlib declarations &gt;&gt;
@others
</t>
<t tx="nickcheng.20070404101530.68">import sys
import time
import string
import socket
import select
import md5
import urllib

"""
MSN Messenger Client Library
by Alberto Bertogli (albertogli@telpin.com.ar)
"""

# constants
VERSION = 0x0305
LOGIN_HOST = 'messenger.hotmail.com'
LOGIN_PORT = 1863

status_table = {
	'online':       'NLN',
	'away':         'AWY',
	'busy':         'BSY',
	'brb':          'BRB',
	'phone':        'PHN',
	'lunch':        'LUN',
	'invisible':    'HDN',
	'idle':         'IDL',
	'offline':      'FLN',
}

reverse_status = {
	'NLN':		'online',
	'AWY':		'away',
	'BSY':		'busy',
	'BRB':		'brb',
	'PHN':		'phone',
	'LUN':		'lunch',
	'HDN':		'invisible',
	'IDL':		'idle',
	'FLN':		'offline',
}


</t>
<t tx="nickcheng.20070404101530.69">def debug(s):
	sys.stderr.write('\r' + str(s) + '\n')
	sys.stderr.flush()
</t>
<t tx="nickcheng.20070404101530.70">def nickquote(nick):
	"""Quotes a nick the way the server likes it: replacing spaces with
	'%20' but leaving extender characters alone, as they get sent UTF-8
	encoded."""
	nick = nick.replace(' ', '%20')
	return nick
</t>
<t tx="nickcheng.20070404101530.71">
class user:
	"""User class, used to store your 'friends'"""
	@others
</t>
<t tx="nickcheng.20070404101530.72">def __init__(self, email = '', nick = '', gid = None):
	self.email = email
	self.nick = nick
	self.realnick = ''
	self.status = 'FLN'
	self.online = 0
	self.gid = gid
	self.homep = None
	self.workp = None
	self.mobilep = None
	self.sbd = None
	self.priv = {}
	self.lists = []
</t>
<t tx="nickcheng.20070404101530.73">def __repr__(self):
	return '&lt;user email:%s nick:"%s" gid:%s&gt;' % (self.email,
			self.nick, self.gid)
</t>
<t tx="nickcheng.20070404101530.74">

class sbd:
	"""SwitchBoard Descriptor
	Used as a pseudo-fd to store per-switchboard connection information.
	The state is either one of (too many):

	[answer]
	cp	connect pending (just came from rng)
	re	ready (just came from connect)
	an	waiting for answer reply

	[invite]
	xf	waiting for xfr response (not even connected yet)
	us	waiting for usr response
	ca	waiting for cal response
	jo	waiting for a join response

	es	established (waiting in boredom)

	You will find more information in the doc directory.
	"""
	@others
</t>
<t tx="nickcheng.20070404101530.75">def __init__(self):
	self.fd = None		# connection fd
	self.state = None	# connection's state (see doc above)
	self.emails = []	# emails we talk to through
	self.msgqueue = []	# outgoing message queue
	self.hash = None	# server-sent hash
	self.session_id = None	# server-sent sid
	self.endpoint = ()	# remote end (ip, port)
	self.type = None	# either 'answer' or 'invite'
	self.tid = 1		# the transaction id, it needs to be
				# unique for consistency
	self.block = 1		# blocking state
	self.orig_tid = None	# tid of the original XFR
</t>
<t tx="nickcheng.20070404101530.76">def __repr__(self):
	return '&lt;sbd: emails:%s state:%s fd:%d endpoint:%s&gt;' % \
		(str(self.emails), self.state, \
		self.fileno(), self.endpoint)
</t>
<t tx="nickcheng.20070404101530.77">def fileno(self):
	return self.fd.fileno()
</t>
<t tx="nickcheng.20070404101530.78">def get_tid(self):
	"Returns a valid tid as string"
	self.tid = self.tid + 1
	return str(self.tid - 1)
</t>
<t tx="nickcheng.20070404101530.79">


class msnd:
	"""MSN Descriptor
	This is the main and most important class; it represents a msn
	instance.

	It's, afaik, nonblocking (not through setblocking() but mainly because
	it forces a select() i/o model (which you would probably have used
	anyway, unless you think async/signal io worths the mess for a stupid
	messenger protocol, or you are a thread freak)), then the reads should
	always succed. Note that we sanely assume that writes do not block.

	Yes yes, you can use poll() too =)

	The only blocking call is the login() which is in charge of doing the
	initial connection and setup, all the rest are cpu bound.

	Once you have created an instance you should assign an email and a
	password at least, then do the login and i recommend you to call sync
	after that (and everyonce in a while doesn't hurt either). Finally you
	change your status and you're ready to idle.

	Oh, and don't forget to set the callbacks: they are the most important
	part, they are the ones which allow you to control the protocol and
	make this useful.

	They are completely asyncronous, are driven by the read method, and
	never block. A special care should be taken if you use threads (which
	you shouldn't need, that was the whole idea behind this), because
	there is not a single lock on these lines, and it will remain that way.

	There is an example (a very bad one, but you'll see how it would work)
	that should have come with this file; also the callback file has good
	working code.
	"""
	@others
</t>
<t tx="nickcheng.20070404101530.80">def __init__(self):
	self.fd = None			# socket fd
	self.sb_fds = []		# switchboard fds
	self.tid = 1			# transaction id

	self.email = None		# login email
	self.pwd = None			# login pwd
	self.nick = None		# nick

	self.homep = None		# home phone
	self.workp = None		# work phone
	self.mobilep = None		# mobile phone

	self.status = 'FLN'		# status
	#self.encoding = 'iso-8859-1'	# local encoding
    self.encoding = 'gb2312'

	self.lhost = LOGIN_HOST
	self.lport = LOGIN_PORT
	self.ns = (None, None)		# notification server
	self.hash = None		# hash used to authenticate

	self.syn_lver = 0		# user list version
	self.syn_total = 10000		# qty. of users from SYN
	self.syn_ngroups = 0		# qty. of groups from SYN

	self.lst_total = 0		# qty. of LSTs got

	self.cb = None			# callbacks

	self.users = {}			# forward user list
	self.reverse = {}		# reverse user list
	self.groups = {}		# group list
</t>
<t tx="nickcheng.20070404101530.81">def __repr__(self):
	return '&lt;msnd object, fd:%s, email:%s, tid:%s&gt;' % (self.fd,
		self.email, self.tid)
</t>
<t tx="nickcheng.20070404101530.82">def fileno(self):
	"Useful for select()"
	return self.fd.fileno()
</t>
<t tx="nickcheng.20070404101530.83">def encode(self, s):
	"Encodes a string from local encoding to utf8"
	try:
		return s.decode(self.encoding).encode('utf-8')
	except:
		return s
</t>
<t tx="nickcheng.20070404101530.84">def decode(self, s):
	"Decodes a string from utf8 to local encoding"
	try:
		return s.decode('utf-8').encode(self.encoding)
	except:
		return s
</t>
<t tx="nickcheng.20070404101530.85">def pollable(self):
	"""Return a pair of lists of poll()/select()ables network
	descriptors (ie. they are not fds, but actually classes that
	implement fileno() methods, like this one and the sbd). We do
	it this way because then it's simpler to read().

	The reason behind the tuple is that for connect-pending fds we
	need to wait for writing readiness, so we must tell the
	userspace so. Notice that it still goes with the read() path.

	Yes, it is a mess but i couldn't find anything better yet. It
	works, it's efficient; let's pretend it's correct =)

	It includes the main file descriptor, and all the switchboards
	connections; then you call self.read(fd) on what this returns,
	and magic happens."""

	iwtd = []
	owtd = []
	iwtd.append(self)
	for nd in self.sb_fds:
		if nd.state == 'cp':	# connect is pending
			owtd.append(nd)
		elif nd.state == 'xf':	# skip this case because it's
					# not connected yet
			pass
		else:			# readable!
			iwtd.append(nd)
	return (iwtd, owtd)
</t>
<t tx="nickcheng.20070404101530.86">def get_tid(self):
	"Returns a valid tid as string"
	self.tid = self.tid + 1
	return str(self.tid - 1)
</t>
<t tx="nickcheng.20070404101530.87">def _send(self, cmd, params = '', nd = None, raw = 0):
	"""Sends a command to the server, building it first as a
	string; uses, if specified, the pseudo fd (it can be either
	msnd or sbd)."""
	if not nd:
		nd = self
	tid = nd.get_tid()
	fd = nd.fd
	c = cmd + ' ' + tid
	if params: c = c + ' ' + params
	debug(str(fd.fileno()) + ' &gt;&gt;&gt; ' + c)
	if not raw:
		c = c + '\r\n'
	c = self.encode(c)
	return fd.send(c)
</t>
<t tx="nickcheng.20070404101530.88">def _recv(self, fd = None):
	"Reads a command from the server, returns (cmd, tid, params)"
	if not fd:
		fd = self.fd
	# cheap and dirty readline, FIXME
	buf = ''
	c = fd.recv(1)
	while c != '\n' and c != '':
		buf = buf + c
		c = fd.recv(1)

	if c == '':
		raise 'SocketError'

	buf = buf.strip()
	pbuf = buf.split(' ')

	cmd = pbuf[0]

	# it's possible that we don't have any params (errors being
	# the most common) so we cover our backs
	if len(pbuf) &gt;= 3:
		tid = pbuf[1]
		params = self.decode(string.join(pbuf[2:]))
	elif len(pbuf) == 2:
		tid = pbuf[1]
		params = ''
	else:
		tid = '0'
		params = ''

	debug(str(fd.fileno()) + ' &lt;&lt;&lt; ' + buf)
	return (cmd, tid, params)
</t>
<t tx="nickcheng.20070404101530.89">def _recvmsg(self, msglen, fd = None):
	"Read a message from the server, returns it"
	if not fd:
		fd = self.fd
	left = msglen
	buf = ''
	while len(buf) != msglen:
		c = fd.recv(left)
		#debug(str(fd.fileno()) + ' &lt;&lt;&lt; ' + buf)
		buf = buf + c
		left = left - len(c)

	return self.decode(buf)
</t>
<t tx="nickcheng.20070404101530.90">def submit_sbd(self, sbd):
	"""Submits a switchboard descriptor to add to our list; it is
	also put on our global list.

	Note that if there is no such user, we create it in order to
	be able to do operations on users that are not in our server
	list."""

	self.sb_fds.append(sbd)
	email = sbd.emails[0]
	if email not in self.users.keys():
		self.users[email] = user(email)
	if self.users[email].sbd and self.users[email].sbd != sbd:
		# override the sbd, but keep the message queue
		sbd.msgqueue = self.users[email].sbd.msgqueue[:]
		self.close(self.users[email].sbd)
	self.users[email].sbd = sbd
	return
</t>
<t tx="nickcheng.20070404101530.91">def change_status(self, st):
	"""Changes the current status to: online, away, busy, brb,
	phone, lunch, invisible, idle, offline"""
	if not status_table.has_key(st): return 0
	self.status = status_table[st]
	self._send('CHG', self.status)
	return 1
</t>
<t tx="nickcheng.20070404101530.92">def privacy(self, public = 1, auth = 0):
	"""Sets our privacy state. First parameter define if you get
	messages from everybody or only from people on your list; the
	second defines if you want users to ask for authorization or
	let everybody add you"""
	if public:	self._send('BLP', 'AL') # be social
	else:		self._send('BLP', 'BL') # live in a cave

	if auth:	self._send('GTC', 'A')	# ask for auth
	else:		self._send('GTC', 'N')	# let them add you

	return 1
</t>
<t tx="nickcheng.20070404101530.93">def change_nick(self, nick):
	"Changes our nick"
	nick = nickquote(nick)
	self._send('REA', self.email + ' ' + nick)
	return 1
</t>
<t tx="nickcheng.20070404101530.94">def sync(self):
	"Syncronizes the tables"
	self._send('SYN', '0')
	return 1
</t>
<t tx="nickcheng.20070404101530.95">def useradd(self, email, nick = None, gid = '0'):
	"Adds a user"
	if not nick: nick = email
	nick = nickquote(nick)
	self._send('ADD', 'AL ' + email + ' ' + nick)
	self._send('ADD', 'FL ' + email + ' ' + nick + ' ' + gid)
	return 1
</t>
<t tx="nickcheng.20070404101530.96">def userdel(self, email):
	"Removes a user"
	self._send('REM', 'AL ' + email)
	self._send('REM', 'FL ' + email)
	return 1
</t>
<t tx="nickcheng.20070404101530.97">def userren(self, email, newnick):
	"Renames a user"
	newnick = nickquote(newnick)
	self._send('REA', email + ' ' + newnick)
	return 1
</t>
<t tx="nickcheng.20070404101530.98">def userblock(self, email):
	self._send('REM', 'AL ' + email)
	self._send('ADD', 'BL ' + email + ' ' + email)
	if 'B' not in self.users[email].lists:
		self.users[email].lists.append('B')
</t>
<t tx="nickcheng.20070404101530.99">def userunblock(self, email):
	self._send('REM', 'BL ' + email)
	self._send('ADD', 'AL ' + email + ' ' + email)
	if 'B' in self.users[email].lists:
		self.users[email].lists.remove('B')
</t>
<t tx="nickcheng.20070404101530.100">def groupadd(self, name):
	"Adds a group"
	name = nickquote(name)
	self._send('ADG', name + ' 0')
	return 1
</t>
<t tx="nickcheng.20070404101530.101">def groupdel(self, gid):
	"Removes a group"
	self._send('RMG', gid)
	return 1
</t>
<t tx="nickcheng.20070404101530.102">def groupren(self, gid, newname):
	newname = nickquote(newname)
	self._send('REG', gid + ' ' + newname)
	return 1
</t>
<t tx="nickcheng.20070404101530.103">def disconnect(self):
	"Disconnect from the server"
	self.fd.send('OUT\r\n')
	self.fd.close()
</t>
<t tx="nickcheng.20070404101530.104">def close(self, sb):
	"Closes a given sbd"
	self.sb_fds.remove(sb)
	self.users[sb.emails[0]].sbd = None
	try:
		self._send('BYE', self.email, nd = sb)
		sb.fd.close()
	except:
		pass
	del(sb)
</t>
<t tx="nickcheng.20070404101530.105">def invite(self, email, sbd):
	"Invites a user into an existing sbd"
	self._send('CAL', email, nd = sbd)
</t>
<t tx="nickcheng.20070404101530.106">def login(self):
	"Logins to the server, really boring"

	# open socket
	self.fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	self.fd.connect((self.lhost, self.lport))

	# version information
	self._send('VER', 'MSNP8 CVR0')

	r = self._recv()
	if r[0] != 'VER' and r[2][0:4] != 'MSNP8':
		raise 'VersionError', r

	# lie the version, just in case
	self._send('CVR', '0x0409 win 4.10 i386 MSNMSGR 5.0.0544 MSMSGS ' + self.email)
	self._recv()	# we just don't care what we get

	# ask for notification server
	self._send('USR', 'TWN I ' + self.email)

	r = self._recv()
	if r[0] != 'XFR' and r[2][0:2] != 'NS':
		raise 'NSError', r

	# parse the notification server ip and port (as int)
	ns = string.split(r[2])[1]
	self.ns = ns.split(':')
	self.ns[1] = int(self.ns[1])
	self.ns = tuple(self.ns)

	# close the fd and reopen it on the ns
	self.fd.close()
	self.fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	self.fd.connect(self.ns)

	# version, same as before
	self._send('VER', 'MSNP8 CVR0')
	r = self._recv()
	if r[0] != 'VER' and r[2][0:4] != 'MSNP8':
		raise 'VersionError', r

	# lie the version, just in case
	self._send('CVR', '0x0409 win 4.10 i386 MSNMSGR 5.0.0544 MSMSGS	' + self.email)
	self._recv()	# we just don't care what we get

	# auth: send user, get hash
	self._send('USR', 'TWN I ' + self.email)

	r = self._recv()
	if r[0] != 'USR':
		raise 'AuthError', r
	hash = string.split(r[2])[2]

	# get and use the passport id
	passportid = self.passport_auth(hash)
	self._send('USR', 'TWN S ' + passportid)

	r = self._recv()
	if r[0] != 'USR' and r[2][0:2] != 'OK':
		raise 'AuthError', r
	self.nick = string.split(r[2])[2]
	self.nick = urllib.unquote(self.nick)

	return 1
</t>
<t tx="nickcheng.20070404101530.107">def passport_auth(self, hash):
	"""Logins into passport and obtains an ID used for
	authorization; it's a helper function for login"""
	import urllib
	import httplib

	# initial connection
	debug('PASSPORT begin')
	nexus = urllib.urlopen('https://nexus.passport.com/rdr/pprdr.asp')
	h = nexus.headers
	purl = h['PassportURLs']

	# parse the info
	d = {}
	for i in purl.split(','):
	        key, val = i.split('=', 1)
		d[key] = val

	# get the login server
	login_server = 'https://' + d['DALogin']
	login_host = d['DALogin'].split('/')[0]

	# build the authentication headers
	ahead =  'Passport1.4 OrgVerb=GET'
	ahead += ',OrgURL=http%3A%2F%2Fmessenger%2Emsn%2Ecom'
	ahead += ',sign-in=' + urllib.quote(self.email)
	ahead += ',pwd=' + urllib.quote(self.pwd)
	ahead += ',lc=1033,id=507,tw=40,fs=1,'
	ahead += 'ru=http%3A%2F%2Fmessenger%2Emsn%2Ecom,ct=1062764229,'
	ahead += 'kpp=1,kv=5,ver=2.1.0173.1,tpf=' + hash
	headers = { 'Authorization': ahead }

	# connect to the given server
	debug('SSL Connect to %s' % login_server)
	ls = httplib.HTTPSConnection(login_host)

	# make the request
	debug('SSL GET')
	ls.request('GET', login_server, '', headers)
	resp = ls.getresponse()

	# loop if we get redirects until we get a definitive answer
	debug('SSL Response %d' % resp.status)
	while resp.status == 302:
		login_server = resp.getheader('Location')
		login_host = login_server.split('/')[2]
		debug('SSL Redirect to %s' % login_server)
		ls = httplib.HTTPSConnection(login_host)
		headers = { 'Authorization': ahead }
		ls.request('GET', login_server, '', headers)
		resp = ls.getresponse()
		debug('SSL Response %d' % resp.status)

	# now we have a definitive answer, if it's not 200 (success)
	# just raise AuthError
	if resp.status != 200:
		# for now we raise 911, which means authentication
		# failed; but maybe we can get more detailed
		# information
		raise 'AuthError', [911, 'SSL Auth failed']

	# and parse the headers to get the passport id
	try:
		ainfo = resp.getheader('Authentication-Info')
	except:
		ainfo = resp.getheader('WWW-Authenticate')

	d = {}
	for i in ainfo.split(','):
		key, val = i.split('=', 1)
		d[key] = val

	passportid = d['from-PP']
	passportid = passportid[1:-1]		# remove the "'"
	return passportid
</t>
<t tx="nickcheng.20070404101530.108">def read(self, nd = None):
	"""Reads from the specified nd and run the callback. The nd
	can be either a msnd or a sbd (that's why it's called 'nd'
	from 'network descriptor').
	"""
	if not nd:
		nd = self

	# handle different stages of switchboard initialization
	if nd in self.sb_fds:
		# connect pending
		if nd.state == 'cp':
			# see if the connect went well
			r = nd.fd.getsockopt(socket.SOL_SOCKET,
				socket.SO_ERROR)
			if r != 0:
				raise 'SocketError', 'ConnectFailed'
			nd.fd.setblocking(1)
			nd.block = 1
			nd.state = 're'

		# need to send the answer to the remote invitation
		if nd.type == 'answer' and nd.state == 're':
			params = self.email + ' ' + nd.hash + ' ' + \
				nd.session_id
			self._send('ANS', params, nd)
			nd.state = 'an'
			return
		if nd.type == 'invite' and nd.state == 're':
			params = self.email + ' ' + nd.hash
			self._send('USR', params, nd)
			nd.state = 'us'
			return



	r = self._recv(nd.fd)
	type = r[0]
	tid = r[1]
	params = string.strip(r[2])

	if   type == 'CHL': self.cb.chl(self, type, tid, params)
	elif type == 'QRY': self.cb.qry(self, type, tid, params)
	elif type == 'ILN': self.cb.iln(self, type, tid, params)
	elif type == 'CHG': self.cb.chg(self, type, tid, params)
	elif type == 'OUT': self.cb.out(self, type, tid, params)
	elif type == 'FLN': self.cb.fln(self, type, tid, params)
	elif type == 'NLN': self.cb.nln(self, type, tid, params)
	elif type == 'BLP': self.cb.blp(self, type, tid, params)
	elif type == 'LST': self.cb.lst(self, type, tid, params)
	elif type == 'GTC': self.cb.gtc(self, type, tid, params)
	elif type == 'SYN': self.cb.syn(self, type, tid, params)
	elif type == 'PRP': self.cb.prp(self, type, tid, params)
	elif type == 'LSG': self.cb.lsg(self, type, tid, params)
	elif type == 'BPR': self.cb.bpr(self, type, tid, params)
	elif type == 'ADD': self.cb.add(self, type, tid, params)
	elif type == 'REA': self.cb.rea(self, type, tid, params)
	elif type == 'REM': self.cb.rem(self, type, tid, params)
	elif type == 'ADG': self.cb.adg(self, type, tid, params)
	elif type == 'RMG': self.cb.rmg(self, type, tid, params)
	elif type == 'REG': self.cb.reg(self, type, tid, params)
	elif type == 'RNG': self.cb.rng(self, type, tid, params)

	elif type == 'IRO': self.cb.iro(self, type, tid, params, nd)
	elif type == 'ANS': self.cb.ans(self, type, tid, params, nd)
	elif type == 'XFR': self.cb.xfr(self, type, tid, params)
	elif type == 'USR': self.cb.usr(self, type, tid, params, nd)
	elif type == 'CAL': self.cb.cal(self, type, tid, params, nd)
	elif type == 'JOI': self.cb.joi(self, type, tid, params, nd)

	elif type == 'ACK': self.cb.ack(self, type, tid, params, nd)
	elif type == 'NAK': self.cb.nak(self, type, tid, params, nd)
	elif type == 'BYE': self.cb.bye(self, type, tid, params, nd)


	elif type == 'MSG':
		params = tid + ' ' + params
		mlen = int(r[2].split()[-1])
		msg = self._recvmsg(mlen, nd.fd)
		self.cb.msg(self, type, params, msg, nd)

	else:
		# catch server errors - always numeric type
		try:
			errno = int(type)
		except:
			errno = None

		if errno:
			self.cb.err(self, errno, \
				str(tid) + ' ' + str(params))
		else:
			# if we got this far, we have no idea
			self.cb.unk(self, type, tid, params)
	return
</t>
<t tx="nickcheng.20070404101530.109">def sendmsg(self, email, msg = '', sb = None):
	"""Sends a message to the user identified by 'email', either
	the one specified or flush the queue.
	Returns:
	1	message queued for delivery
	2	queue flushed
	-2	the message is too big

	To verify the message delivery, use the ack callbacks.
	Message sending order is guaranteed within a sbd; but not the
	acknowledge; that's what the ACK/NAK callbacks are for.
	"""

	if email and email not in self.users.keys():
		self.users[email] = user(email)

	if len(msg) &gt; 1500:
		return -2

	if not sb:
		sb = self.users[email].sbd

	# we don't have a connection
	if not sb:
		sb = sbd()
		sb.state = 'xf'
		sb.type = 'invite'
		sb.emails.append(email)
		sb.msgqueue.append(msg)

		self.submit_sbd(sb)	# no need to connect it yet
		# we set the orig_tid of the sbd to the next tid (that
		# is, the tid the XFR is going to have), in order to
		# be able to identify it later, in cb.cb_xfr()
		sb.orig_tid = str(self.tid)
		self._send('XFR', 'SB')
		return 1

	# it's not ready yet
	elif sb.state != 'es':
		sb.msgqueue.append(msg)
		return 1

	# no more excuses, send it
	else:
		# we make a list with all the messages to send
		pend = sb.msgqueue
		if msg:
			pend.append(msg)
		while len(pend):
			m = pend[0]
			header = "MIME-Version: 1.0\r\n" + \
				"Content-Type: text/plain; " + \
				"charset=UTF-8\r\n\r\n"
			m = header + m
			msize = len(self.encode(m))
			params = 'A ' + str(msize) + '\r\n' + m
			self._send('MSG', params, sb, raw = 1)
			del(pend[0])

		return 2
</t>
<t tx="nickcheng.20070404101530.110">@ignore
@language python
&lt;&lt; msncb declarations &gt;&gt;
@others
</t>
<t tx="nickcheng.20070404101530.111">import string
import urllib
import md5

import socket

import msnlib

"""
This is the home for the msn callback class and examples (that might move to
another file in the near future).

There are three types of callbacks: the error one (this is only one), the
server ones (handle connections, notifications, lists and stuff like that),
and the switchboard ones (which handle messaging).

All of them receive as their first argument an 'md' (msn descriptor) that is
the main connection object; you probably already know what it is.

The models are:
error: 		def cb_err(md, errno, params)
server:		def cb_def(md, type, tid, params)
switchboard:	def cb_usr(md, type, tid, params, sbd)

See below for more examples.

Probably you should base your own callbacks on these ones, at least they were
thought with that in mind, so you can use yours as wrappers that handle only
your app-specific code and forget about the protocol-specific mess.

		Alberto (albertogli@telpin.com.ar)
"""


# use the debug function from msnlib
debug = msnlib.debug


</t>
<t tx="nickcheng.20070404101530.112">class cb:
	@others
</t>
<t tx="nickcheng.20070404101530.113">def __init__(self):
	self.unk = cb_unk	# unknown
	self.err = cb_err	# server error
	self.msg = cb_msg	# get a message
	self.chl = cb_chl	# challenge
	self.qry = cb_ign	# query response
	self.iln = cb_iln	# status notification
	self.chg = cb_ign	# status change
	self.nln = cb_nln	# status notification
	self.fln = cb_fln	# status offline
	self.out = cb_out	# disconnect
	self.blp = cb_ign	# privacy mode change
	self.lst = cb_lst	# list requests
	self.bpr = cb_bpr	# user info
	self.gtc = cb_ign	# add notification
	self.syn = cb_syn	# list sync confirmation
	self.prp = cb_prp	# private info
	self.lsg = cb_lsg	# group list
	self.add = cb_add	# user add
	self.rem = cb_rem	# user remove
	self.adg = cb_adg	# group add
	self.rmg = cb_rmg	# group del
	self.reg = cb_reg	# group rename
	self.rea = cb_rea	# nick change
	self.rng = cb_rng	# switchboard invitation
	self.iro = cb_iro	# multi-user chat
	self.ans = cb_ans	# answer confirmation
	self.xfr = cb_xfr	# switchboard request
	self.usr = cb_usr	# sb request initial identification
	self.cal = cb_ign	# call confirmation
	self.joi = cb_joi	# session join
	self.ack = cb_ack	# message acknowledge
	self.nak = cb_nak	# message negative acknowledge
	self.bye = cb_bye	# switchboard user disconnect
</t>
<t tx="nickcheng.20070404101530.114">error_table = {
	-10: 'Local error',
	200: 'Syntax error',
	201: 'Invalid parameter',
	205: 'Invalid user',
	206: 'Domain name missing',
	207: 'Already logged in',
	208: 'Invalid username',
	209: 'Invalid fusername',
	210: 'User list full',
	215: 'User already there',
	216: 'User already on list',
	217: 'User not online',
	218: 'Already in mode',
	219: 'User is in the opposite list',
	280: 'Switchboard failed',
	281: 'Transfer to switchboard failed',
	300: 'Required field missing',
	302: 'Not logged in',
	500: 'Internal server error',
	501: 'Database server error',
	510: 'File operation failed',
	520: 'Memory allocation failed',
	600: 'Server is busy',
	601: 'Server is unavaliable',
	602: 'Peer nameserver is down',
	603: 'Database connection failed',
	604: 'Server is going down',
	707: 'Could not create connection',
	711: 'Write is blocking',
	712: 'Session is overloaded',
	713: 'Too many active users',
	714: 'Too many sessions',
	715: 'Not expected',
	717: 'Bad friend file',
	911: 'Authentication failed',
	913: 'Not allowed when offline',
	920: 'Not accepting new users',
}

def cb_err(md, errno, params):
	"Handle server errors"
	if not error_table.has_key(errno):
		desc = 'Unknown error %d' % errno
	else:
		desc = error_table[errno]

	debug('SERVER ERROR %d: %s - %s' % (errno, desc, params))
</t>
<t tx="nickcheng.20070404101530.115">def cb_def(md, type, tid, params):
	"Default callback. It just prints the args"
	debug('DEFAULT type: ' + type + ' :: Params: ' + str(params))
</t>
<t tx="nickcheng.20070404101530.116">def cb_unk(md, type, tid, params):
	"Handles the unknown types"
	debug('Error! unknown event type "%s"' % type)
	debug('params: ' + str(params))
</t>
<t tx="nickcheng.20070404101530.117">def cb_chl(md, type, tid, params):
	"Handles the challenges"
	if type != 'CHL': raise 'CallbackMess', (md, type, params)
	hash = params + 'VT6PX?UQTM4WM%YR' # magic from www.hypothetic.org
	hash = md5.md5(hash).hexdigest()
	md._send('QRY', 'PROD0038W!61ZTF9 32')
	md.fd.send(hash)
</t>
<t tx="nickcheng.20070404101530.118">def cb_ign(md, type, tid, params, nd = None):
	"Ignores"
	pass
</t>
<t tx="nickcheng.20070404101530.119">def cb_out(md, type, tid, params):
	"Server disconnected us"
	debug('!!! Server closed the connection: ' + params)
</t>
<t tx="nickcheng.20070404101530.120">def cb_iln(md, type, tid, params):
	"Handles a friend status change"
	t = params.split(' ')
	status = t[0]
	email = t[1]
	if len(params) &gt; 2: nick = urllib.unquote(t[2])
	else: nick = ''

	md.users[email].status = status
	md.users[email].realnick = nick
	debug('FRIEND %s (%s) changed status to :%s:' % (nick, email, status))
</t>
<t tx="nickcheng.20070404101530.121">def cb_fln(md, type, tid, params):
	"Handles a friend disconnection"
	email = tid
	debug('FRIEND %s disconnected (%s)' % (email, type))
	md.users[email].status = type
</t>
<t tx="nickcheng.20070404101530.122">def cb_nln(md, type, tid, params):
	"Handles a friend status change"
	status = tid
	t = params.split(' ')
	email = t[0]
	if len(t) &gt; 1: nick = urllib.unquote(t[1])
	else: nick = ''

	md.users[email].status = status
	md.users[email].realnick = nick
	debug('FRIEND %s (%s) changed status to :%s:' % (nick, email, status))
</t>
<t tx="nickcheng.20070404101530.123">def cb_bpr(md, type, tid, params):
	"Update friend info"
	# the email is deduced from the last lst we got; if it's None it means
	# that we come from an add (the protocol behaves different if coming
	# from SYN or ADD)
	email = md._last_lst
	if email:
		# we come from SYN
		type = tid
		param = urllib.unquote(params)
	else:
		# we come from ADD
		t = params.split(' ')
		email = t[0]
		type = t[1]
		if len(t) &gt;= 3:
			param = urllib.unquote(t[2])
		else:
			param = ''

	if not md.users.has_key(email): return

	if   type == 'PHH': md.users[email].homep = param
	elif type == 'PHW': md.users[email].workp = param
	elif type == 'PHM': md.users[email].mobilep = param
	else: pass
</t>
<t tx="nickcheng.20070404101530.124">def cb_syn(md, type, tid, params):
	"Receive a SYN notification"
	t = params.split()
	if len(t) != 3:
		raise "SYNError"

	lver = int(t[0])
	total = int(t[1])
	ngroups = int(t[2])

	md.syn_lver = lver
	md.syn_total = total
	md.syn_ngroups = ngroups
</t>
<t tx="nickcheng.20070404101530.125">def cb_lst(md, type, tid, params):
	p = params.split(' ')
	email = tid
	nick = urllib.unquote(p[0])
	listmask = int(p[1])
	if len(p) == 3:
		groups = p[2]
	else:
		groups = '0'

	# we only use one main group id
	gid = groups.split(',')[0]

	if email in md.users.keys():
		user = md.users[email]
	else:
		user = msnlib.user(email, nick, gid)

	# the list mask is a bitmask, composed of:
	# FL: 1
	# AL: 2
	# BL: 4
	# RL: 8

	# in forward
	if listmask &amp; 1:
		user.lists.append('F')
		md.users[email] = user

	# in reverse
	if listmask &amp; 8:
		user.lists.append('R')
		md.reverse[email] = user

	# in allow
	if listmask &amp; 2:
		user.lists.append('A')

	# in block
	if listmask &amp; 4:
		user.lists.append('B')

	md.lst_total += 1

	# save in the global last_lst the email, because BPRs might need it
	md._last_lst = email
</t>
<t tx="nickcheng.20070404101530.126">def cb_lsg(md, type, tid, params):
	"Handles group list"
	p = params.split(' ')
	gid = tid
	name, unk = p[0:]
	# if we get the group 0, start from scratch
	if gid == '0':
		md.groups = {}
	name = urllib.unquote(name)
	md.groups[gid] = name
</t>
<t tx="nickcheng.20070404101530.127">def cb_prp(md, type, tid, params):
	"Handles private info"
	t = params.split(' ')
	type = t[0]
	if len(t) &gt; 1: param = urllib.unquote(t[1])
	else: param = ''

	if   type == 'PHH': md.homep = param
	elif type == 'PHW': md.workp = param
	elif type == 'PHM': md.mobilep = param
	else: pass
</t>
<t tx="nickcheng.20070404101530.128">def cb_add(md, type, tid, params):
	"Handles a user add; both you adding a user and a user adding you"
	t = params.split(' ')
	type = t[0]
	if type == 'RL':
		email = t[2]
		nick = urllib.unquote(t[3])
		debug('ADD: %s (%s) added you' % (nick, email))
	elif type == 'FL':
		email = t[2]
		nick = urllib.unquote(t[3])
		gid = t[4]
		md.users[email] = msnlib.user(email, nick, gid)
		# put None in last_lst so BPRs know it's not coming from sync
		md._last_lst = None
		debug('ADD: adding %s (%s)' % (email, nick))
	else:
		pass
</t>
<t tx="nickcheng.20070404101530.129">def cb_rem(md, type, tid, params):
	"""Handles a user del.
	Only make something in the case of a user removing you"""
	t = params.split(' ')
	type = t[0]
	if type == 'RL':
		email = t[2]
		debug('REM: %s removed you' % email)
	elif type == 'FL':
		email = t[2]
		if md.users[email].sbd:
			md.close(md.users[email].sbd)
		del(md.users[email])
		debug('REM: removing %s' % email)
	else:
		pass
</t>
<t tx="nickcheng.20070404101530.130">def cb_adg(md, type, tid, params):
	"Handle a group add"
	t = params.split(' ')
	lver, name, gid = t[0:3]
	md.groups[gid] = name
	debug('ADG: group %s (%s) added' % (name, gid))
</t>
<t tx="nickcheng.20070404101530.131">def cb_rmg(md, type, tid, params):
	"Handle a group del"
	t = params.split(' ')
	lver, gid = t[0:2]
	for e in md.users.keys():
		if md.users[e].gid == gid:
			if md.users[e].sbd:
				md.close(md.users[e].sbd)
			del(md.users[e])
	del(md.groups[gid])
	debug('RMG: group %s removed' % gid)
</t>
<t tx="nickcheng.20070404101530.132">def cb_reg(md, type, tid, params):
	"Handle a group rename"
	t = params.split(' ')
	gid = t[1]
	name = t[2]
	md.groups[gid] = name
	debug('REG: group %s renamed to %s' % (name, gid))
</t>
<t tx="nickcheng.20070404101530.133">def cb_rea(md, type, tid, params):
	"Handles our info change"
	t = params.split(' ')
	email = t[1]
	nick = urllib.unquote(t[2])
	if email != md.email:
		md.users[email].nick = nick
	else:
		md.nick = nick
	debug('NICK CHANGE: email %s - nick %s' % (email, nick))
</t>
<t tx="nickcheng.20070404101530.134">def cb_rng(md, type, tid, params):
	"Handles switchboard invitations."
	t = params.split(' ')
	sid = tid
	ip, port = t[0].split(':')
	port = int(port)
	hash = t[2]
	email = t[3]

	fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	# we set the socket nonblocking so we don't block (duh!) on connect();
	# it will be picked up later from the select loop and handled via the
	# main read() call, which you will have to see to find out the rest.
	fd.setblocking(0)
	fd.connect_ex((ip, port))

	sbd = msnlib.sbd()
	sbd.fd = fd
	sbd.block = 0
	sbd.state = 'cp'
	sbd.type = 'answer'
	sbd.endpoint = (ip, port)
	sbd.emails.append(email)
	sbd.hash = hash
	sbd.session_id = sid
	md.submit_sbd(sbd) 		# it has the connect pending
</t>
<t tx="nickcheng.20070404101530.135">def cb_xfr(md, type, tid, params):
	"Handles switchboard requests"
	t = params.split(' ')
	ip, port = t[1].split(':')
	port = int(port)
	hash = t[3]

	fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	fd.setblocking(0)		# see cb_rng
	fd.connect_ex((ip, port))

	# look for the sbd, matching the tid
	sbd = None
	for i in md.sb_fds:
		if i.state == 'xf' and i.orig_tid == tid:
			sbd = i
			break
	if not sbd:
		debug('AIEEE: XFR without sbd!')
		raise 'XFRError', (type, tid, params)

	sbd.fd = fd
	sbd.block = 0
	sbd.state = 'cp'
	sbd.endpoint = (ip, port)
	sbd.hash = hash
</t>
<t tx="nickcheng.20070404101530.136">def cb_iro(md, type, tid, params, sbd):
	"Handles the switchboard participant list"
	p = params.split(' ')
	uid, ucount, email, nick = p
	if ucount == '1':
		# do nothing if we only have one participant
		return
	else:
		if email not in md.users.keys():
			md.users[email] = msnlib.user(email)
		if email not in sbd.emails:
			sbd.emails.append(email)
		debug("FRIEND %s joined chat with %s" % (email, sbd.emails[0]))
</t>
<t tx="nickcheng.20070404101530.137">def cb_usr(md, type, tid, params, sbd):
	"Handles switchboard requests initial identification"
	email = sbd.emails[0]
	md._send('CAL', email, sbd)
	sbd.state = 'ca'
</t>
<t tx="nickcheng.20070404101530.138">def cb_joi(md, type, tid, params, sbd):
	"Handles a switchboard join, and sends the pending messages"
	email = tid
	# if it's a multi-user chat, just append it to the list
	if sbd.emails and email != sbd.emails[0]:
		sbd.emails.append(email)
		if email not in md.users.keys():
			md.users[email] = msnlib.user(email)
		debug('CALL: user %s joined chat with %s' % \
			(email, sbd.emails[0]))
	# otherwise (common path) set up the sbd and flush the messages
	else:
		sbd.state = 'es'
		debug('CALL: user %s replied your chat request; flushing' % email)
		md.sendmsg(email)
		debug('CALL: message queue for %s flushed' % email)
</t>
<t tx="nickcheng.20070404101530.139">def cb_ans(md, type, tid, params, sbd):
	"""Answer confirmation to an invitation, replied after the connect()
	ending by read()"""
	sbd.state = 'es'
</t>
<t tx="nickcheng.20070404101530.140">def cb_msg(md, type, tid, params, sbd):
	"Get a message"
	debug('MESSAGE\n+++ Header: %s\n%s\n\n' % (str(tid), str(params)))
</t>
<t tx="nickcheng.20070404101530.141">def cb_ack(md, type, tid, params, sbd):
	"Get a message acknowledge"
	debug('ACK: tid:%s' % tid)
</t>
<t tx="nickcheng.20070404101530.142">def cb_nak(md, type, tid, params, sbd):
	"Get a message negative acknowledge"
	debug('NAK: tid:%s' % tid)
</t>
<t tx="nickcheng.20070404101530.143">def cb_bye(md, type, tid, params, sbd):
	"Handles a user sb disconnect"
	email = tid
	if email != sbd.emails[0]:
		debug('BYE: user %s leaving sbd' % email)
		if email in sbd.emails:
			sbd.emails.remove(email)
	else:
		debug('BYE: closing %s' % str(sbd))
		md.close(sbd)
</t>
</tnodes>
</leo_file>
